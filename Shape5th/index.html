<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Ninja: Shape Mastery</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Shojumaru&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #f4e4bc; /* Parchment color */
            background-image: radial-gradient(#dcc289 15%, transparent 16%),
            radial-gradient(#dcc289 15%, transparent 16%);
            background-size: 60px 60px;
            background-position: 0 0, 30px 30px;
            font-family: 'Shojumaru', cursive; /* Ninja style font */
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* UI Elements */
        #hud {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #current-rule {
            font-size: 32px;
            color: #d80000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 40px;
            border-radius: 5px;
            border: 4px solid #000;
            display: inline-block;
            box-shadow: 5px 5px 0px rgba(0,0,0,0.2);
        }

        .stats-box {
            position: absolute;
            top: 20px;
            font-size: 24px;
            color: #333;
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 5px;
            border: 2px solid #333;
        }

        #score-box { left: 20px; }
        #lives-box { right: 20px; color: #d80000; }

        /* Screens */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: white;
        }

        .hidden { display: none !important; }

        h1 { font-size: 60px; color: #ffcc00; text-shadow: 4px 4px #d80000; margin: 0; }
        p { font-size: 20px; max-width: 600px; text-align: center; line-height: 1.6; }

        button {
            background: #d80000;
            color: white;
            border: 4px solid white;
            font-family: 'Shojumaru', cursive;
            font-size: 28px;
            padding: 15px 50px;
            cursor: pointer;
            transition: 0.2s;
            margin-top: 30px;
        }
        button:hover { transform: scale(1.1); background: #ff4b4b; }

        canvas { display: block; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="hud">
            <div id="current-rule">Loading...</div>
        </div>
        <div id="score-box" class="stats-box">Score: 0</div>
        <div id="lives-box" class="stats-box">Lives: 3</div>

        <div id="start-screen" class="overlay">
            <h1>GEOMETRY NINJA</h1>
            <p>
                Sensei will shout a command (e.g., "Strike Pentagons!").<br>
                <strong>SWIPE</strong> across the screen to cut the matching shapes.<br>
                Avoid the bombs and don't cut the wrong shapes!
            </p>
            <button onclick="startGame()">ENTER DOJO</button>
        </div>

        <div id="game-over" class="overlay hidden">
            <h1 style="color: #d80000;">DEFEAT</h1>
            <p style="font-size: 30px;">Final Score: <span id="final-score">0</span></p>
            <button onclick="startGame()">TRAIN AGAIN</button>
        </div>

        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        // --- Game Logic ---
        const GAME_CONFIG = {
            gravity: 0.15,
            spawnRate: 60, // frames
        };

        let state = {
            running: false,
            score: 0,
            lives: 3,
            shapes: [],
            particles: [],
            mouseIsDown: false,
            trail: [], // Mouse trail path
            currentRule: null, // The active condition
            timeSinceLastSpawn: 0,
            combo: 0
        };

        // Shape Database (Standard 5 Level)
        const SHAPE_DEFS = [
            { id: 'tri', name: 'Triangle', sides: 3, type: '2d', color: '#ffeb3b' },      // Yellow
            { id: 'square', name: 'Square', sides: 4, type: '2d', color: '#2196f3' },     // Blue
            { id: 'rect', name: 'Rectangle', sides: 4, type: '2d', color: '#03a9f4' },    // Light Blue
            { id: 'pent', name: 'Pentagon', sides: 5, type: '2d', color: '#4caf50' },     // Green
            { id: 'hex', name: 'Hexagon', sides: 6, type: '2d', color: '#8bc34a' },      // Light Green
            { id: 'oct', name: 'Octagon', sides: 8, type: '2d', color: '#009688' },      // Teal
            { id: 'cube', name: 'Cube', sides: 6, type: '3d', color: '#9c27b0' },         // Purple
            { id: 'bomb', name: 'BOMB', sides: 0, type: 'bomb', color: '#333' }
        ];

        // Possible Rules (Conditions for the player)
        const RULES = [
            { text: "Cut 4-Sided Shapes!", check: (s) => s.sides === 4 && s.type !== 'bomb' },
            { text: "Cut Triangles!", check: (s) => s.sides === 3 },
            { text: "Cut 5+ Sided Shapes!", check: (s) => s.sides >= 5 },
            { text: "Cut 3D Shapes!", check: (s) => s.type === '3d' },
            { text: "Cut Quadrilaterals!", check: (s) => s.sides === 4 && s.type !== 'bomb' },
            { text: "Cut Everything but Bombs!", check: (s) => s.type !== 'bomb' }
        ];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Input Handling (Mouse & Touch)
        function addPoint(x, y) {
            state.trail.push({x, y, age: 10});
            checkCollisions(x, y);
        }
        
        window.addEventListener('mousedown', () => state.mouseIsDown = true);
        window.addEventListener('mouseup', () => { state.mouseIsDown = false; state.trail = []; state.combo = 0; });
        window.addEventListener('mousemove', (e) => {
            if(state.mouseIsDown && state.running) addPoint(e.clientX, e.clientY);
        });

        window.addEventListener('touchstart', (e) => state.mouseIsDown = true);
        window.addEventListener('touchend', () => { state.mouseIsDown = false; state.trail = []; state.combo = 0; });
        window.addEventListener('touchmove', (e) => {
            if(state.running) {
                e.preventDefault();
                addPoint(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});


        function spawnShape() {
            // Pick random template
            const template = SHAPE_DEFS[Math.floor(Math.random() * SHAPE_DEFS.length)];
            
            // Physics setup
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = canvas.height + 50;
            const vx = (Math.random() - 0.5) * 8; // Horizontal spread
            const vy = -(Math.random() * 8 + 10); // Throw up velocity
            const rotSpeed = (Math.random() - 0.5) * 0.1;

            state.shapes.push({
                x, y, vx, vy, rot: 0, rotSpeed,
                ...template,
                active: true,
                radius: 40 // Hitbox size
            });
        }

        function switchRule() {
            const newRule = RULES[Math.floor(Math.random() * RULES.length)];
            state.currentRule = newRule;
            document.getElementById('current-rule').innerText = newRule.text;
            
            // Flash effect
            document.getElementById('current-rule').style.transform = "scale(1.2)";
            setTimeout(() => document.getElementById('current-rule').style.transform = "scale(1)", 200);
        }

        function checkCollisions(mx, my) {
            for(let shape of state.shapes) {
                if(!shape.active) continue;

                // Distance check (Circle collision for simplicity)
                const dx = mx - shape.x;
                const dy = my - shape.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if(dist < shape.radius) {
                    sliceShape(shape);
                }
            }
        }

        function sliceShape(shape) {
            shape.active = false; // Remove from screen
            createParticles(shape.x, shape.y, shape.color);

            // Logic Check
            if(shape.type === 'bomb') {
                state.lives--;
                updateHUD();
                screenShake();
                if(state.lives <= 0) gameOver();
                return;
            }

            if(state.currentRule.check(shape)) {
                // Correct Slice
                state.combo++;
                state.score += 10 * state.combo;
                updateHUD();
            } else {
                // Wrong Slice
                state.lives--;
                state.combo = 0;
                updateHUD();
                if(state.lives <= 0) gameOver();
            }
        }

        function createParticles(x, y, color) {
            for(let i=0; i<10; i++) {
                state.particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0,
                    color: color
                });
            }
        }

        function updateHUD() {
            document.getElementById('score-box').innerText = "Score: " + state.score;
            document.getElementById('lives-box').innerText = "Lives: " + "♥".repeat(state.lives);
        }

        // --- Drawing Helper Functions ---
        function drawPolygon(ctx, x, y, radius, sides, rotation) {
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI / sides) + rotation;
                const px = x + radius * Math.cos(angle);
                const py = y + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        function drawCube(ctx, x, y, size, rotation) {
            // Simple Wireframe Cube projection
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            ctx.lineWidth = 3;
            // Front face
            ctx.strokeRect(-size/2, -size/2, size, size);
            // Back face offset
            const off = size * 0.4;
            ctx.strokeRect(-size/2 + off, -size/2 - off, size, size);
            // Connecting lines
            ctx.beginPath();
            ctx.moveTo(-size/2, -size/2); ctx.lineTo(-size/2 + off, -size/2 - off);
            ctx.moveTo(size/2, -size/2); ctx.lineTo(size/2 + off, -size/2 - off);
            ctx.moveTo(size/2, size/2); ctx.lineTo(size/2 + off, size/2 - off);
            ctx.moveTo(-size/2, size/2); ctx.lineTo(-size/2 + off, size/2 - off);
            ctx.stroke();
            
            // Fill mostly transparent
            ctx.fillStyle = "rgba(156, 39, 176, 0.3)";
            ctx.fillRect(-size/2, -size/2, size, size);
            ctx.restore();
        }

        function drawBomb(ctx, x, y, radius) {
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI*2);
            ctx.fillStyle = "black";
            ctx.fill();
            
            // Fuse
            ctx.beginPath();
            ctx.moveTo(x, y - radius);
            ctx.quadraticCurveTo(x + 10, y - radius - 20, x + 20, y - radius - 10);
            ctx.strokeStyle = "#d80000";
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Spark
            if(Math.random() > 0.5) {
                ctx.fillStyle = "orange";
                ctx.fillRect(x+18, y-radius-12, 4, 4);
            }
            
            // Skull mark
            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.fillText("☠", x-10, y+7);
        }

        // --- Main Game Loop ---
        function gameLoop() {
            if(!state.running) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Spawner logic
            state.timeSinceLastSpawn++;
            if(state.timeSinceLastSpawn > GAME_CONFIG.spawnRate) {
                spawnShape();
                // occasionally spawn a second one
                if(Math.random() > 0.6) spawnShape();
                state.timeSinceLastSpawn = 0;
            }

            // 2. Update & Draw Shapes
            for(let i = state.shapes.length - 1; i >= 0; i--) {
                let s = state.shapes[i];
                if(!s.active) { state.shapes.splice(i, 1); continue; }

                // Physics
                s.x += s.vx;
                s.y += s.vy;
                s.vy += GAME_CONFIG.gravity;
                s.rot += s.rotSpeed;

                // Draw
                ctx.fillStyle = s.color;
                ctx.strokeStyle = "black";
                ctx.lineWidth = 3;

                if(s.type === 'bomb') {
                    drawBomb(ctx, s.x, s.y, s.radius);
                } else if (s.type === '3d') {
                    ctx.strokeStyle = s.color;
                    drawCube(ctx, s.x, s.y, s.radius, s.rot);
                } else {
                    drawPolygon(ctx, s.x, s.y, s.radius, s.sides, s.rot);
                    // Add text for sides for learning reinforcement
                    ctx.fillStyle = "black";
                    ctx.font = "bold 16px Arial";
                    ctx.textAlign = "center";
                    // Only show number if it's not a bomb
                    if(s.sides > 0) ctx.fillText(s.sides, s.x, s.y);
                }

                // Remove if off screen
                if(s.y > canvas.height + 100) {
                    state.shapes.splice(i, 1);
                }
            }

            // 3. Draw Blade Trail
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.lineWidth = 8;
            for(let i=0; i<state.trail.length; i++) {
                let p = state.trail[i];
                if(i===0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
                p.age--;
            }
            ctx.stroke();
            // Remove old trail points
            state.trail = state.trail.filter(p => p.age > 0);

            // 4. Draw Particles
            for(let i=state.particles.length-1; i>=0; i--) {
                let p = state.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, 8, 8);
                ctx.globalAlpha = 1;
                if(p.life <= 0) state.particles.splice(i,1);
            }

            // 5. Change Rule Occasionally
            if(Math.random() < 0.002) switchRule();

            requestAnimationFrame(gameLoop);
        }

        // Screen shake effect
        function screenShake() {
            const container = document.getElementById('game-container');
            container.style.transform = "translate(5px, 5px)";
            setTimeout(() => container.style.transform = "translate(-5px, -5px)", 50);
            setTimeout(() => container.style.transform = "translate(0, 0)", 100);
        }

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over').classList.add('hidden');
            state.running = true;
            state.score = 0;
            state.lives = 3;
            state.shapes = [];
            state.particles = [];
            switchRule();
            updateHUD();
            requestAnimationFrame(gameLoop);
        }

        function gameOver() {
            state.running = false;
            document.getElementById('game-over').classList.remove('hidden');
            document.getElementById('final-score').innerText = state.score;
        }

    </script>
</body>
</html>